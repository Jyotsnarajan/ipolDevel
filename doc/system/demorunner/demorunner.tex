\section{DemoRunner module}
\label{sec:DemoRunner}
This module controls the execution of the IPOL demos. In order to achieve Reproducible Research, the DemoRunner must ensure that the code which the demo executes is exactly the same that the users would download from the article's page.

As a first step for the execution, the Core module prepares a \emph{run folder} for the experiment with the input files converted according to the DDL specifications. Since most of the algorithms are well parallelized, typically they take as much as CPU cores as possible. Thus, several machines are needed to execute several demos at the same without a loss of performance. The system shares the load according to the configured policy (see Sec.~\ref{sec:Dispatcher}). This leads to a distributed system with several DemoRunners (see Sec.~\ref{sec:Dispatcher}), where each machine able to run demos has one installed. The DemoRunner is responsible of informing the Core about the load of the machine where it is running on. This allows to have several machines with different requirements for the demos (for example, MATLAB, or any specific libraries).

The DemoRunner module executes the experiment according to this workflow:

\begin{enumerate}
    \item Ensure the compilation,
    \item execute and control,
    \item control exceptions and failures. 
\end{enumerate}

\subsection{Ensure compilation}
\noindent

This step ensures that IPOL always uses the last version of the source codes provided by the authors. 

The first time that a demo is executed, the module downloads, extracts, and compiles the source codes from the URL specified at the DDL. This URL is the link where the author's codes are stored. The, the specified files (say, the binaries or scripts) are moved to the binaries directory.

Henceforth, DemoRunner will compare differences between the information from the HTTP header of the remote file with its local copy. If there have been any modifications in the size or the dates, the system will consider the local copy out of day and it will download and compile the sources again. 


\subsubsection{Virtualenv}
\noindent

This step creates if specified by the DDL, a Virtualenv with the required packages. This process only executes when building the demo which is the first time it is executed or when a the source files are updated.

A Virtualenv per demo is the only way to securely avoid package conflicts for each demo as different demos might need different package versions. Globally installing packages would end up in confliting package installation.

The system will create the virtual environment inside the bin folder along with the binaries needed to execute the demo. To activate the Virtualenv the user will have to execute the activation script from a bash file for example.


\subsection{Execute and control}
\noindent

The second responsibility of the module is to control the execution.  It can execute directly the authors binaries or, for more complex process, support scripts provided by the demo editors in a particular demo (see more about \textit{DemoExtras} in Sec.~\ref{sec:demoextras}). Besides, the demo editors can call some generic scripts provided by the system, for example to draw 2D curves, or draw histograms, among others. These scripts in the {\tt PythonTools} directory are added to the PATH during execution.

Before an experiment, the module receives all the information that it needs, such as the the ID of the demo, the execution key, a suggested time for stopping execution (to avoid experiments that take too long), and the parameters set by the user in the web interface.

Nevertheless, in other cases the process is not so simple and some additional mechanism is needed to show the results.  Let's suppose an optical flow demo. Usually, this type of demos uses a pair of consecutive images as input to calculate the displacement field between them. However, sometimes you can also include a ground truth that represents exactly the motion present between the inputs. This ground truth helps to measure how close is your solution respect to the best possible flow field using different error measures. For this, it is mandatory that the web interface makes the difference between these two types of executions. \miguel{I don't get this. What do you mean? What is the relationship with the Core?}


This module provides a mechanism that allows the caller to recover information added during the execution. Let's think of a demo with a variable number of outputs. If the web interface uses a repeat gallery to show these images, it needs to know how many times it needs to repeat, but this information is only known after the execution. The solution is simple: the demo editor writes the name and value of one or many variables to a text file {\tt algo\_info.txt} and the system will read it after the execution.


\subsection{Control exceptions and failures}
\noindent

The module takes care of stopping the demo execution if a problem is detected. It can be in the preparation of the execution (not supported inputs for the demo, a runtime error, incorrect syntax in the run section at the DDL, for example). In these cases, the module notifies the caller about the causes of the failure.

Another reason for stopping an execution is when a demo exceeds a configured running time. It can be because of a malfunction in the author's program that makes it never finish or simply because the execution time is too long (a timeout). The demo editors can configure a maximum timeout in the DDLs. In any cae, the DemoRunner has its own maximum timeout which can override what the user configured in case that was too short or too long.
